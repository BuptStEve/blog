title: 「15」让我们优雅地调用接口获取数据
date: 2018-11-05 11:08:00
categories: 全栈
tags: [tua, api]
---

## 零、问题的由来
开门见山地说，这篇文章就是一篇安利软文~，安利的对象就是最近搞的 [tua-api](https://github.com/tuateam/tua-api)。

顾名思义，这就是一款辅助调用接口 api，获取接口数据的工具。

> 发请求的工具辣么多，那我为啥要用你呢？

哎，别急~，让我们先回顾一下有关如何发请求的历史。

## 一、常规操作
### 1.1.原生 XHR (XMLHttpRequest)
说到发请求，最经典的方式莫过于调用浏览器原生的 XHR。在此不赘述，有兴趣可以看看[MDN 上的文档](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)。

```js
var xhr = window.XMLHttpRequest
    ? new XMLHttpRequest()
    // 在万恶的 IE 上可能还没有 XMLHttpRequest 这对象
    : new ActiveXObject('Microsoft.XMLHTTP')

xhr.open('GET', 'some url')
xhr.responseType = 'json'

// 传统使用 onreadystatechange
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
    }
}

// 或者直接使用 onload 事件
xhr.onload = function () {
    console.log(xhr.response)
}

// 处理出错
xhr.onerror = console.error

xhr.send()
```

这代码都不用看，想想就头皮发麻...

### 1.2.jQuery 封装的 ajax
由于原生 XHR 写起来太繁琐，再加上当时 jQuery 如日中天。日常开发中用的比较多的还是 jQuery 提供的 ajax 方法。[jQuery ajax 文档点这里](http://api.jquery.com/jquery.ajax/)

```js
var params = {
    url: 'some url',
    data: { name: 'Steve', location: 'Beijing' },
}

$.ajax(params)
    .done(console.log)
    .fail(console.error)
```

jQuery 不仅封装了 XHR，还十分贴心地提供跨域的 jsonp 功能。

```js
$.ajax({
    url: 'some url',
    data: { name: 'Steve', location: 'Beijing' },
    dataType: 'jsonp',
    success: console.log,
    error: console.error,
})
```

讲道理，jQuery 的 ajax 已经很好用了。然而随着 Vue、React、Angular 的兴起，连 jQuery 本身都被革命了。新项目为了发个请求还引入巨大的 jQuery 肯定不合理，当然后面这些替代方案也功不可没...

### 1.3.现代浏览器的原生 fetch
XHR 是一个设计粗糙的 API。记得当年笔试某部门的实习生的时候就有手写 XHR 的题目，我反正记不住 api，并没有写出来...

fetch api 基于 Promise 设计，调用起来比 XHR 方便多了。

```js
fetch(url)
    .then(res => res.json())
    .then(console.log)
    .catch(console.error)
```

async/await 自然也能使用

```js
try {
    const data = await fetch(url).then(res => res.json())
    console.log(data)
} catch (e) {
    console.error(e)
}
```

当然 fetch 也有不少的问题

* 兼容性问题
* 使用繁琐，详见参考文献之 [fetch 没有你想象的那么美][3]
* 不支持 jsonp（虽然理论上不应该支持，但实际上需要使用）
* 只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
* 默认不会带 cookie，需要添加配置项
* 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.race 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
* 没有办法原生监测请求的进度，而 XHR 可以

### 1.4.基于 Promise 的 axios
axios 算是请求框架中的明星项目了。目前 github 5w+ 的 star...

先来看看有什么特性吧~

* 同时支持浏览器端和服务端的请求。（XMLHttpRequests、http）
* 支持 Promise
* 支持请求和和数据返回的拦截
* 转换请求返回数据，自动转换JSON数据
* 支持取消请求
* 客户端防止 xsrf 攻击

确实是居家旅行全栈开发必备好库，[但是 axios 并不支持 jsonp...](https://github.com/axios/axios/issues/342#issuecomment-224327183)

### 1.5.不得不用的 jsonp
在服务器端不方便配置跨域头的情况下，采用 jsonp 的方式发起跨域请求是一种常规操作。

在此不探究具体的实现，原理上来说就是

* 由于 script 标签可以设置跨域的来源，所以首先动态插入一个 script，将 src 设置为目标地址
* 服务端收到请求后，根据回调函数名（可自己约定，或作为参数传递）将 json 数据填入。例如 `callback({ "foo": "bar" })`。（顾名思义 json padding...）
* 浏览器端收到这个函数后自然会调用，那么回调函数就收到了服务端填入的 json 数据了。

上面讲到新项目一般都弃用 jQuery 了，那么跨域请求还是得发呀。所以可能你还需要一个发送 jsonp 的库。（实践中选了 `fetch-jsonp`）

## 二、接口层
对于简单的页面，直接裸写请求地址也没毛病。但是一旦项目变大，页面数量也上去了，直接在页面，或是组件中裸写接口的话，会带来以下问题

* 代码冗余：很多接口请求都是类似的代码，有许多相同的逻辑
* 不方便切换测试域名
* 不方便编写接口注释
* 没法实现统一拦截器、甚至中间件功能

理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层中的函数。

以 `fooApi` 中的 `bar` 接口为例

```js
import { fooApi } from '@/apis/'

fooApi
    .bar({ a: '1', b: '2' }) // 发起请求，a、b 是请求参数
    .then(console.log)       // 收到响应
    .catch(console.error)    // 处理错误
```

> 如何封装呢？

### 2.1.接口地址划分
首先我们来分析一下接口地址的组成

* `https://example-base.com/something/create`
* `https://example-base.com/something/modify`
* `https://example-base.com/something/delete`

以上地址，一般将其分为3部分

* host: `'https://example-base.com/'`
* prefix: `'something'`
* pathList: `[ 'create', 'modify', 'delete' ]`

### 2.2.文件结构


## 参考文献
* [Jquery ajax, Axios, Fetch区别之我见][1]
* [传统 Ajax 已死，Fetch 永生][2]
* [fetch 没有你想象的那么美][3]
* [fetch 使用的常见问题及解决方法][4]

[1]: https://segmentfault.com/a/1190000012836882
[2]: https://github.com/camsong/blog/issues/2
[3]: http://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/
[4]: https://www.cnblogs.com/huilixieqi/p/6494380.html
